1. Event driven scheduling allows for simple scheduling of processes. Instead of a complex timesharing scheme, events simply preempt the system's main loop and perform their task. Queueing can be used to resolve time conflicts. It is also particularly useful for embedded devices which often contain sensors and respond programatically when triggered by some event (a user interacting with a touchscreen, a timer triggering a sprinkler system, a sensor detecting rain, etc.). A downside of event driven programming is that the code can often lack a hierarchal structure making it difficult to develop large applications. Components within an event driven application can act independently, or be triggered by other components, or even a series of other components. Once an application becomes sufficienlty large it can be nearly impossible to debug. 

2. By having both flooding checks and TTL, we can prevent both endless cyclic packet flooding and packet transmission away from the destination. If we had only TTL implemented without flooding checks then packets would be forwarded uneccessarily in cycles and indeirect routes until their TTLs expired. This is wasted bandwidth on the network as the packet has already been forwarded thorugh those nodes. With flooding checks and no TTL, packets can continue to be forwarded further and further away from the destination. If the topology of the network is somewhat linear this could result in a majority of the network receiving the packet despite being nowhere close to the destination. This situation also results in wasted bandwidth.

3. 

4. Using neighbor discovery we can set up a system for routing packets towards their destination along the most efficient route(s). Each node would only need to know the direction to send the packet on its next hop, through one of its neighbor nodes. This would require keeping a list (or table) of nodes and the neighbor node through which to route the packet.

5. An alternative approach to our neighbor discovery implementation would be to implement a new protocol, say PROTOCOL_NEIGHBORDISCOVERY. This would be a more explicit and elegant solution than our approach of sending a PING with a destination 0. Since all nodes are numbered [1-n], with n being the number of nodes the broadcast domain, our implementation is fully functional. The recipient nodes respond by changing the source to their node id and respong with a PINGREPLY, thereby signaling they are a neighbor. TTL is limited to 1 so the packet is not retransmitted beyond immediate neighbors. A con of this system is that it does rely on the node numbering scheme aforementioned. This scheme may not be guaranteed, nor may it be optimal as the network can hold one fewer node than it otherwise could have. A pro of the system is that it doesn't introduce the complexity of a new protocol. It is not always realistic to simply implement a new protocol for every problem that arrises, as much of network architecture is implemented at the hardware/firmware level making it very hard, or even impossible, to update.